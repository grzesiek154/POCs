/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn how to create Gradle builds at https://guides.gradle.org/creating-new-gradle-builds/
 */

task hello {
    doLast {
        println 'Hello World'
    }
}



task upper {
    doLast {
        String someString = 'mY_nAmE'
        println "Original: $someString"
        println "Upper case: ${someString.toUpperCase()}"
    }
}



task count {
    doLast {
        4.times { print "$it " }
    }
}

task intro {
    dependsOn hello
    doLast {
        println " => Siema!!!"
    }
}

// 4.times { counter ->
//     task "task$counter" {
//         doLast {
//             println "I'm task number $counter"
//         }
//     }
// }

// Manipulating existing tasks

// Once tasks are created they can be accessed via an API. For instance, you could use this to dynamically add dependencies to a task, at runtime. Ant doesn’t allow anything like this.


4.times { counter->
    task "task$counter" {
        doLast {
            println "I'm task number $counter"
        }
    }
}

task0.dependsOn task2, task3


hello.doFirst {
    println 'Hello Venus'
}

hello.configure {
    doLast {
        println 'Hello Mars'
    }
}

hello.configure {
    doLast {
        println 'Hello Jupiter'
    }
}


// Task properties

task myTask {
    ext.myProperty = "myValue"
}

task printTaskProperties {
    doLast {
        println myTask.myProperty
    }
}

//Using methods

// Using Ant Tasks

// Ant tasks are first-class citizens in Gradle. Gradle provides excellent integration for Ant tasks by simply relying on Groovy. Groovy is shipped with the fantastic AntBuilder. Using Ant tasks from Gradle is as convenient and more powerful than using Ant tasks from a build.xml file. And it is usable from Kotlin too. From the example below, you can learn how to execute Ant tasks and how to access Ant properties:



task loadfile {
    doLast {
        def files = file('./antLoadfileResources').listFiles().sort()
        files.each { File file ->
            if (file.isFile()) {
                ant.loadfile(srcFile: file, property: file.name)
                println " *** $file.name ***"
                println "${ant.properties[file.name]}"
            }
        }
    }
}

// task checksum {
//     doLast {
//         fileList('./antLoadfileResources').each { File file ->
//             ant.checksum(file: file, property: "cs_$file.name")
//             println "$file.name Checksum: ${ant.properties["cs_$file.name"]}"
//         }
//     }
// }

// task loadfile {
//     doLast {
//         fileList('./antLoadfileResources').each { File file ->
//             ant.loadfile(srcFile: file, property: file.name)
//             println "I'm fond of $file.name"
//         }
//     }
// }

// File[] fileList(String dir) {
//     file(dir).listFiles({file -> file.isFile() } as FileFilter).sort()
// }


//Default tasks

defaultTasks 'clean', 'run'

task clean {
    doLast {
        println 'Default Cleaning!'
    }
}

task run {
    doLast {
        println 'Default Running!'
    }
}

task other {
    doLast {
        println "I'm not a default task!"
    }
}





// Configure by DAG

// As we later describe in full detail (see Build Lifecycle), Gradle has a configuration phase and an execution phase. After the configuration phase, Gradle knows all tasks that should be executed. Gradle offers you a hook to make use of this information. A use-case for this would be to check if the release task is among the tasks to be executed. Depending on this, you can assign different values to some variables.

// In the following example, execution of the distribution and release tasks results in different value of the version variable.





task distribution {
    doLast {
        println "We build the zip with version=$version"
    }
}

task release {
    dependsOn 'distribution'
    doLast {
        println 'We release now'
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(":release")) {
        version = '1.0'
    } else {
        version = '1.0-SNAPSHOT'
    }
}

// The important thing is that whenReady affects the release task before the release task is executed. This works even when the release task is not the primary task (i.e., the task passed to the gradle command).




// External dependencies for the build script

// If your build script needs to use external libraries, you can add them to the script’s classpath in the build script itself. You do this using the buildscript() method, passing in a block which declares the build script classpath.



// The block passed to the buildscript() method configures a ScriptHandler instance. You declare the build script classpath by adding dependencies to the classpath configuration. This is the same way you declare, for example, the Java compilation classpath. You can use any of the dependency types except project dependencies.

// Having declared the build script classpath, you can use the classes in your build script as you would any other classes on the classpath. The following example adds to the previous example, and uses classes from the build script classpath.

import org.apache.commons.codec.binary.Base64

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: 'commons-codec', name: 'commons-codec', version: '1.2'
    }
}

task encode {
    doLast {
        def byte[] encodedString = new Base64().encode('hello world\n'.getBytes())
        println new String(encodedString)
    }
}